<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Jojo’s Pod — Adaptive Masonry Grid</title>
<style>
  :root{
    --bg:#f7f5f2;
    --accent:#144055;
    --muted:#666;
    --gap:18px;
    --min-col:240px; /* 调整这个值可以改变最小列宽，从而影响列数 */
    --row-height:8px; /* grid-auto-rows 的基准高度（px） */
  }

  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: Inter, "Noto Sans SC", system-ui, -apple-system, "Helvetica Neue", Arial;
    background:var(--bg); color:#222;
  }

  header{
    padding:20px; display:flex; align-items:center; gap:12px; border-bottom:1px solid rgba(0,0,0,0.04);
  }
  .logo{font-weight:700;color:var(--accent)}
  .hero{max-width:1200px;margin:18px auto;padding:12px 20px}
  .hero h1{margin:0;color:var(--accent);font-size:20px}
  .hero p{margin:6px 0 0;color:var(--muted)}

  .controls{max-width:1200px;margin:12px auto;padding:6px 20px;display:flex;align-items:center}
  .filters{display:flex;gap:8px;flex-wrap:wrap}
  .filters button{
    padding:8px 12px;border-radius:999px;border:1px solid rgba(0,0,0,0.06);
    background:#fff;cursor:pointer;font-size:13px;color:var(--muted);
  }
  .filters button.active{color:var(--accent);border-color:var(--accent);font-weight:600}

  /* ========== Grid container ========== */
  .masonry-wrap{max-width:1400px;margin:0 auto;padding:0 20px 80px;}
  .masonry{
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--min-col), 1fr));
    gap: var(--gap);
    grid-auto-rows: calc(var(--row-height) * 1px); /* JS 用此值来计算跨行数量 */
    align-items: start;
  }

  /* card */
  .card{
    background:#fff;border-radius:12px;overflow:hidden;
    box-shadow: 0 6px 20px rgba(15,43,61,0.04);
    border:1px solid rgba(0,0,0,0.03);
    transition: transform .35s cubic-bezier(.2,.8,.2,1), box-shadow .35s ease;
    display:flex;flex-direction:column;
  }
  .card:hover{transform:translateY(-8px);box-shadow:0 18px 40px rgba(15,43,61,0.09);}

  .thumb{display:block;width:100%;}
  .card img{display:block;width:100%;height:auto;transition:transform .7s ease;}
  .card:hover img{transform:scale(1.03);}

  .meta{padding:12px 14px;display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--muted);}
  .title{margin:0;padding:0 14px 8px;color:var(--accent);font-size:16px}
  .desc{margin:0;padding:0 14px 18px;color:#333;font-size:14px;line-height:1.45}

  .badge{display:inline-block;padding:6px 10px;border-radius:999px;font-size:12px;color:#fff}
  .pod{background:#2b6fa3}
  .print{background:#b56a45}
  .paint{background:#4a8a5e}

  .hidden{display:none !important;}

  footer{padding:36px 20px;text-align:center;color:var(--muted);font-size:13px}

  /* small screen tweaks */
  @media (max-width:700px){
    :root{--min-col:180px} /* 更小屏时减小最小列宽帮助多列出现 */
  }
</style>
</head>
<body>

<header>
  <div class="logo">Jojo’s Pod</div>
  <nav style="margin-left:auto;color:var(--muted)"><a href="#" style="color:inherit;text-decoration:none;margin-left:12px">About</a></nav>
</header>

<section class="hero">
  <h1>Jojo’s Works — sound · print · painting</h1>
  <p>Three rhythms of one inquiry — browse experiments, prints and paintings.</p>
</section>

<div class="controls">
  <div class="filters" role="tablist" aria-label="filter">
    <button class="filter-btn active" data-filter="all">All</button>
    <button class="filter-btn" data-filter="pod">Podcast</button>
    <button class="filter-btn" data-filter="print">Printworks</button>
    <button class="filter-btn" data-filter="paint">Paintings</button>
  </div>
</div>

<div class="masonry-wrap">
  <div class="masonry" id="masonry">
    <!-- 示例卡片（替换图片与文本） -->
    <article class="card pod">
      <img class="thumb" src="https://picsum.photos/seed/ep6/900/900" alt="Ep6 Spiral">
      <div class="meta"><span class="badge pod">Podcast</span><span>Ep.6</span></div>
      <h3 class="title">Spiral to the Universe ~ 和弦陀螺</h3>
      <p class="desc">一段短小的音像实验：从五度链到对数螺线，轻轻旋转。</p>
    </article>

    <article class="card pod">
      <img class="thumb" src="https://picsum.photos/seed/ep5/700/700" alt="Ep5">
      <div class="meta"><span class="badge pod">Podcast</span><span>Ep.5</span></div>
      <h3 class="title">从薛定谔到一块橡皮章</h3>
      <p class="desc">关于物理、手作与记忆的小段思考。</p>
    </article>

    <article class="card print">
      <img class="thumb" src="https://picsum.photos/seed/print1/800/1200" alt="Print1">
      <div class="meta"><span class="badge print">Print</span><span>Print 01</span></div>
      <h3 class="title">铭记 · θεὸν περιφέρεις</h3>
      <p class="desc">书签与木刻的短辑，纪念性的图像小物。</p>
    </article>

    <article class="card paint">
      <img class="thumb" src="https://picsum.photos/seed/paint1/900/1100" alt="Paint1">
      <div class="meta"><span class="badge paint">Painting</span><span>Work A</span></div>
      <h3 class="title">二次生长 · 再生的姿态</h3>
      <p class="desc">亚麻布上的小画，关于时间与复苏。</p>
    </article>

    <!-- 更多 card 放在这里 -->
  </div>
</div>

<footer>© Jojo’s Pod — sound · print · painting</footer>

<script>
/* ---- 优化版：高效 Grid Masonry 布局 ----
   替换你页面中原来的布局脚本。
   要点：
   - 只在图片加载时计算对应 card 的 row-span（避免一次性遍历所有）
   - 批量 DOM 读写使用 rAF（requestAnimationFrame）
   - 忽略 .hidden 元素，resize 防抖
   - 建议：为 <img> 加上 loading="lazy" 与 width/height 或 srcset
*/

const grid = document.getElementById('masonry');
if (!grid) {
  console.warn('masonry container not found');
} else {
  // 从 CSS 读取基础行高与 gap（以 px 为单位）
  const css = getComputedStyle(document.documentElement);
  const baseRow = parseFloat(css.getPropertyValue('--row-height')) || 8;
  let gridGap = parseFloat(getComputedStyle(grid).getPropertyValue('gap')) || 18;

  // 用于批量写入的队列
  const writeQueue = [];
  let isWriting = false;

  function scheduleWrite(fn) {
    writeQueue.push(fn);
    if (!isWriting) {
      isWriting = true;
      requestAnimationFrame(() => {
        let task;
        while ((task = writeQueue.shift())) {
          try { task(); } catch (e) { console.error(e); }
        }
        isWriting = false;
      });
    }
  }

  // 计算并设置单个 card 的 row span（只读高度一次）
  function setItemRowSpan(item) {
    // 忽略被隐藏的
    if (item.classList.contains('hidden')) return;

    // read: get height (this causes layout read)
    const itemRect = item.getBoundingClientRect();
    const itemHeight = Math.ceil(itemRect.height);

    // compute span using row height + gap
    const span = Math.max(1, Math.ceil((itemHeight + gridGap) / (baseRow + gridGap)));

    // write: set style in rAF via scheduleWrite
    scheduleWrite(() => {
      item.style.gridRowEnd = 'span ' + span;
    });
  }

  // 只处理当前视口附近的 items（少量优化）
  function visibleItems() {
    // use IntersectionObserver-like coarse filter using viewport height + buffer
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
    const buffer = vh * 1.5; // 扩展范围，避免滚动中突然卡顿
    const scrollTop = window.scrollY || window.pageYOffset;
    const topLimit = scrollTop - buffer;
    const bottomLimit = scrollTop + vh + buffer;

    return Array.from(grid.querySelectorAll('.card')).filter(it => {
      if (it.classList.contains('hidden')) return false;
      const r = it.getBoundingClientRect();
      const top = r.top + scrollTop;
      const bottom = top + r.height;
      return !(bottom < topLimit || top > bottomLimit);
    });
  }

  // 主入口：重新布局可见 items（逐个）
  function relayoutVisible() {
    // recompute gap each time (in case css changed)
    gridGap = parseFloat(getComputedStyle(grid).getPropertyValue('gap')) || gridGap;
    const items = visibleItems();
    items.forEach(setItemRowSpan);
  }

  // 图片加载单张时触发对应 card 重算（最有效）
  function bindImageListeners() {
    const imgs = grid.querySelectorAll('img');
    imgs.forEach(img => {
      // if already handled, skip
      if (img.__masonry_bound) return;
      img.__masonry_bound = true;

      // If image is complete, set its card now
      if (img.complete) {
        const parent = img.closest('.card');
        if (parent) setItemRowSpan(parent);
      } else {
        img.addEventListener('load', (e) => {
          const parent = img.closest('.card');
          if (parent) setItemRowSpan(parent);
        }, {passive: true});
        img.addEventListener('error', () => {
          const parent = img.closest('.card');
          if (parent) setItemRowSpan(parent);
        }, {passive: true});
      }
    });
  }

  // 过滤后需要重新计算（例如用户点击分类）
  function relayoutAllVisibleAfterFilter() {
    // small timeout to allow DOM display changes to take effect
    setTimeout(relayoutVisible, 80);
  }

  // 初始化
  function initMasonry() {
    bindImageListeners();
    // initial layout for items whose images already loaded
    setTimeout(relayoutVisible, 80);
  }

  // 防抖 resize
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      // recalc baseRow/gap in case CSS variables changed due to media queries
      const computed = getComputedStyle(document.documentElement);
      // update if changed
      // baseRow = parseFloat(computed.getPropertyValue('--row-height')) || baseRow;
      gridGap = parseFloat(getComputedStyle(grid).getPropertyValue('gap')) || gridGap;
      relayoutVisible();
    }, 150);
  }, {passive: true});

  // MutationObserver：当 DOM 中卡片增删、类名变化时（例如筛选）触发重布局
  const mo = new MutationObserver((mutations) => {
    let shouldRebind = false;
    for (const m of mutations) {
      if (m.type === 'childList' || m.type === 'attributes') shouldRebind = true;
    }
    if (shouldRebind) {
      bindImageListeners();
      relayoutAllVisibleAfterFilter();
    }
  });
  mo.observe(grid, {childList: true, subtree: true, attributes: true, attributeFilter: ['class']});

  // Optional: IntersectionObserver 仅对进入视口的元素做动画或再次微调
  const io = new IntersectionObserver(entries => {
    entries.forEach(ent => {
      if (ent.isIntersecting) {
        const card = ent.target;
        card.classList.add('in-viewport');
        // layout this card for better alignment
        setItemRowSpan(card);
        io.unobserve(card); // only once
      }
    });
  }, { root: null, rootMargin: '200px 0px' });

  // observe each card (for animation + late layout)
  grid.querySelectorAll('.card').forEach(card => {
    io.observe(card);
  });

  // run init
  window.requestAnimationFrame(initMasonry);
}
</script>

